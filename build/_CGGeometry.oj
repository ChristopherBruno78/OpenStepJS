{"LOG":[],"sourceFile":"../Frameworks/Foundation/_CGGeometry.j","objectFile":"../build/_CGGeometry.oj","code":"// @typedef CGPoint\nobjj_registerTypeDef(objj_allocateTypeDef(\"CGPoint\"));\n// @typedef CGSize\nobjj_registerTypeDef(objj_allocateTypeDef(\"CGSize\"));\n// @typedef CGRect\nobjj_registerTypeDef(objj_allocateTypeDef(\"CGRect\"));\n// @typedef CGInset\nobjj_registerTypeDef(objj_allocateTypeDef(\"CGInset\"));\n\nfunction CGPointMake(x, y)\n{\n    return {\n        x: x,\n        y: y\n    };\n}\n\nfunction CGPointMakeZero()\n{\n    return {\n        x: 0,\n        y: 0\n    };\n}\n\nfunction CGPointMakeCopy(aPoint)\n{\n    return {\n        x: aPoint.x,\n        y: aPoint.y\n    };\n}\n\nCGPointCreateCopy = CGPointMakeCopy;\n\nfunction CGPointEqualToPoint(lhsPoint, rhsPoint)\n{\n    return lhsPoint.x == rhsPoint.x && lhsPoint.y == rhsPoint.y;\n}\n\nfunction CGStringFromPoint(aPoint)\n{\n    return \"{\" + aPoint.x + \", \" + aPoint.y + \"}\";\n}\n\nfunction CGSizeMake(width, height)\n{\n    return {\n        width: width,\n        height: height\n    };\n}\n\nfunction CGSizeMakeZero()\n{\n    return {\n        width: 0,\n        height: 0\n    };\n}\n\nfunction CGSizeMakeCopy(aSize)\n{\n    return {\n        width: aSize.width,\n        height: aSize.height\n    };\n}\n\nCGSizeCreateCopy = CGSizeMakeCopy;\n\nfunction CGSizeEqualToSize(lhsSize, rhsSize)\n{\n    return lhsSize.width == rhsSize.width && lhsSize.height == rhsSize.height;\n}\n\nfunction CGStringFromSize(aSize)\n{\n    return \"{\" + aSize.width + \", \" + aSize.height + \"}\";\n}\n\nfunction CGRectMake(x, y, width, height)\n{\n    return {\n        origin: {\n            x: x,\n            y: y\n        },\n        size: {\n            width: width,\n            height: height\n        }\n    };\n}\n\nfunction CGRectMakeZero()\n{\n    return {\n        origin: {\n            x: 0,\n            y: 0\n        },\n        size: {\n            width: 0,\n            height: 0\n        }\n    };\n}\n\nfunction CGRectMakeCopy(aRect)\n{\n    return {\n        origin: {\n            x: aRect.origin.x,\n            y: aRect.origin.y\n        },\n        size: {\n            width: aRect.size.width,\n            height: aRect.size.height\n        }\n    };\n}\n\nCGRectCreateCopy = CGRectMakeCopy;\n\nfunction CGRectEqualToRect(lhsRect, rhsRect)\n{\n    return lhsRect.origin.x == rhsRect.origin.x && lhsRect.origin.y == rhsRect.origin.y && lhsRect.size.width == rhsRect.size.width && lhsRect.size.height == rhsRect.size.height;\n}\n\nfunction CGStringFromRect(aRect)\n{\n    return \"{\" + CGStringFromPoint(aRect.origin) + \", \" + CGStringFromSize(aRect.size) + \"}\";\n}\n\nfunction CGRectOffset(aRect, dX, dY)\n{\n    return {\n        origin: {\n            x: aRect.origin.x + dX,\n            y: aRect.origin.y + dY\n        },\n        size: {\n            width: aRect.size.width,\n            height: aRect.size.height\n        }\n    };\n}\n\nfunction CGRectInset(aRect, dX, dY)\n{\n    return {\n        origin: {\n            x: aRect.origin.x + dX,\n            y: aRect.origin.y + dY\n        },\n        size: {\n            width: aRect.size.width - 2 * dX,\n            height: aRect.size.height - 2 * dY\n        }\n    };\n}\n\nfunction CGRectGetHeight(aRect)\n{\n    return aRect.size.height;\n}\n\nfunction CGRectGetMaxX(aRect)\n{\n    return aRect.origin.x + aRect.size.width;\n}\n\nfunction CGRectGetMaxY(aRect)\n{\n    return aRect.origin.y + aRect.size.height;\n}\n\nfunction CGRectGetMidX(aRect)\n{\n    return aRect.origin.x + aRect.size.width / 2.0;\n}\n\nfunction CGRectGetMidY(aRect)\n{\n    return aRect.origin.y + aRect.size.height / 2.0;\n}\n\nfunction CGRectGetMinX(aRect)\n{\n    return aRect.origin.x;\n}\n\nfunction CGRectGetMinY(aRect)\n{\n    return aRect.origin.y;\n}\n\nfunction CGRectGetWidth(aRect)\n{\n    return aRect.size.width;\n}\n\nfunction CGRectIsEmpty(aRect)\n{\n    return aRect.size.width <= 0.0 || aRect.size.height <= 0.0 || aRect.origin.x === Infinity || aRect.origin.y === Infinity;\n}\n\nfunction CGRectIsNull(aRect)\n{\n    return aRect.origin.x === Infinity || aRect.origin.y === Infinity;\n}\n\nfunction CGRectContainsPoint(aRect, aPoint)\n{\n    return aPoint.x >= aRect.origin.x && aPoint.y >= aRect.origin.y && aPoint.x < CGRectGetMaxX(aRect) && aPoint.y < CGRectGetMaxY(aRect);\n}\n\nfunction CGInsetMake(top, right, bottom, left)\n{\n    return {\n        top: top,\n        right: right,\n        bottom: bottom,\n        left: left\n    };\n}\n\nfunction CGInsetMakeZero()\n{\n    return {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n    };\n}\n\nfunction CGInsetMakeCopy(anInset)\n{\n    return {\n        top: anInset.top,\n        right: anInset.right,\n        bottom: anInset.bottom,\n        left: anInset.left\n    };\n}\n\nfunction CGInsetMakeInvertedCopy(anInset)\n{\n    return {\n        top: -anInset.top,\n        right: -anInset.right,\n        bottom: -anInset.bottom,\n        left: -anInset.left\n    };\n}\n\nfunction CGInsetIsEmpty(anInset)\n{\n    return anInset.top === 0 && anInset.right === 0 && anInset.bottom === 0 && anInset.left === 0;\n}\n\nfunction CGInsetEqualToInset(lhsInset, rhsInset)\n{\n    return lhsInset.top === rhsInset.top && lhsInset.right === rhsInset.right && lhsInset.bottom === rhsInset.bottom && lhsInset.left === rhsInset.left;\n}\n\nCGMinXEdge = 0;\nCGMinYEdge = 1;\nCGMaxXEdge = 2;\nCGMaxYEdge = 3;\nCGRectNull = CGRectMake(Infinity, Infinity, 0.0, 0.0);\n\nfunction CGRectDivide(inRect, slice, rem, amount, edge)\n{\n    slice.origin = CGPointMakeCopy(inRect.origin);\n    slice.size = CGSizeMakeCopy(inRect.size);\n    rem.origin = CGPointMakeCopy(inRect.origin);\n    rem.size = CGSizeMakeCopy(inRect.size);\n\n    switch (edge)\n    {\n        case CGMinXEdge:\n            slice.size.width = amount;\n            rem.origin.x += amount;\n            rem.size.width -= amount;\n            break;\n\n        case CGMaxXEdge:\n            slice.origin.x = CGRectGetMaxX(slice) - amount;\n            slice.size.width = amount;\n            rem.size.width -= amount;\n            break;\n\n        case CGMinYEdge:\n            slice.size.height = amount;\n            rem.origin.y += amount;\n            rem.size.height -= amount;\n            break;\n\n        case CGMaxYEdge:\n            slice.origin.y = CGRectGetMaxY(slice) - amount;\n            slice.size.height = amount;\n            rem.size.height -= amount;\n    }\n}\n\nfunction CGRectContainsRect(lhsRect, rhsRect)\n{\n    var union = CGRectUnion(lhsRect, rhsRect);\n\n    return CGRectEqualToRect(union, lhsRect);\n}\n\nfunction CGRectIntersectsRect(lhsRect, rhsRect)\n{\n    var intersection = CGRectIntersection(lhsRect, rhsRect);\n\n    return !CGRectIsEmpty(intersection);\n}\n\nfunction CGRectIntegral(aRect)\n{\n    aRect = CGRectStandardize(aRect);\n\n    var x = FLOOR(CGRectGetMinX(aRect)),\n        y = FLOOR(CGRectGetMinY(aRect));\n\n    aRect.size.width = CEIL(CGRectGetMaxX(aRect)) - x;\n    aRect.size.height = CEIL(CGRectGetMaxY(aRect)) - y;\n    aRect.origin.x = x;\n    aRect.origin.y = y;\n\n    return aRect;\n}\n\nfunction CGRectIntersection(lhsRect, rhsRect)\n{\n    var intersection = CGRectMake(MAX(CGRectGetMinX(lhsRect), CGRectGetMinX(rhsRect)), MAX(CGRectGetMinY(lhsRect), CGRectGetMinY(rhsRect)), 0, 0);\n\n    intersection.size.width = MIN(CGRectGetMaxX(lhsRect), CGRectGetMaxX(rhsRect)) - CGRectGetMinX(intersection);\n    intersection.size.height = MIN(CGRectGetMaxY(lhsRect), CGRectGetMaxY(rhsRect)) - CGRectGetMinY(intersection);\n\n    return CGRectIsEmpty(intersection) ? CGRectMakeZero() : intersection;\n}\n\nfunction CGRectStandardize(aRect)\n{\n    var width = CGRectGetWidth(aRect),\n        height = CGRectGetHeight(aRect),\n        standardized = CGRectMakeCopy(aRect);\n\n    if (width < 0.0)\n    {\n        standardized.origin.x += width;\n        standardized.size.width = -width;\n    }\n\n    if (height < 0.0)\n    {\n        standardized.origin.y += height;\n        standardized.size.height = -height;\n    }\n\n    return standardized;\n}\n\nfunction CGRectUnion(lhsRect, rhsRect)\n{\n    var lhsRectIsNull = !lhsRect || lhsRect === CGRectNull,\n        rhsRectIsNull = !rhsRect || rhsRect === CGRectNull;\n\n    if (lhsRectIsNull)\n        return rhsRectIsNull ? CGRectNull : rhsRect;\n\n    if (rhsRectIsNull)\n        return lhsRectIsNull ? CGRectNull : lhsRect;\n\n    var minX = MIN(CGRectGetMinX(lhsRect), CGRectGetMinX(rhsRect)),\n        minY = MIN(CGRectGetMinY(lhsRect), CGRectGetMinY(rhsRect)),\n        maxX = MAX(CGRectGetMaxX(lhsRect), CGRectGetMaxX(rhsRect)),\n        maxY = MAX(CGRectGetMaxY(lhsRect), CGRectGetMaxY(rhsRect));\n\n    return CGRectMake(minX, minY, maxX - minX, maxY - minY);\n}\n\nfunction CGRectInsetByInset(aRect, anInset)\n{\n    return CGRectMake(aRect.origin.x + anInset.left, aRect.origin.y + anInset.top, aRect.size.width - anInset.left - anInset.right, aRect.size.height - anInset.top - anInset.bottom);\n}\n\nfunction CGPointFromString(aString)\n{\n    var comma = aString.indexOf(',');\n\n    return {\n        x: parseFloat(aString.substr(1, comma - 1)),\n        y: parseFloat(aString.substring(comma + 1, aString.length))\n    };\n}\n\nfunction CGSizeFromString(aString)\n{\n    var comma = aString.indexOf(',');\n\n    return {\n        width: parseFloat(aString.substr(1, comma - 1)),\n        height: parseFloat(aString.substring(comma + 1, aString.length))\n    };\n}\n\nfunction CGRectFromString(aString)\n{\n    var comma = aString.indexOf(',', aString.indexOf(',') + 1);\n\n    return {\n        origin: CGPointFromString(aString.substr(1, comma - 1)),\n        size: CGSizeFromString(aString.substring(comma + 2, aString.length - 1))\n    };\n}\n\nfunction CGPointFromEvent(anEvent)\n{\n    return CGPointMake(anEvent.clientX, anEvent.clientY);\n}\n\nfunction CGInsetUnion(lhsInset, rhsInset)\n{\n    return CGInsetMake(lhsInset.top + rhsInset.top, lhsInset.right + rhsInset.right, lhsInset.bottom + rhsInset.bottom, lhsInset.left + rhsInset.left);\n}\n\nfunction CGInsetDifference(lhsInset, rhsInset)\n{\n    return CGInsetMake(lhsInset.top - rhsInset.top, lhsInset.right - rhsInset.right, lhsInset.bottom - rhsInset.bottom, lhsInset.left - rhsInset.left);\n}\n\nfunction CGInsetFromString(aString)\n{\n    var numbers = (aString.substr(1, aString.length - 2)).split(',');\n\n    return CGInsetMake(parseFloat(numbers[0]), parseFloat(numbers[1]), parseFloat(numbers[2]), parseFloat(numbers[3]));\n}\n\nCGInsetFromCPString = CGInsetFromString;\n\nfunction CPStringFromCGInset(anInset)\n{\n    return \"{\" + anInset.top + \", \" + anInset.left + \", \" + anInset.bottom + \", \" + anInset.right + \"}\";\n}\n\nfunction CGAlignStroke(coord, strokeWidth)\n{\n    return FLOOR(coord) === coord ? coord + strokeWidth / 2 : coord;\n}\n\nfunction CGAlignCoordinate(coord)\n{\n    return FLOOR(coord);\n}\n","superclassRefs":[],"classDefs":[],"dependencies":[]}